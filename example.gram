module {
	val PositiveInt = Int<(x=>x>-1)>;
	val NegativeInt = Int<(x=>x< 1)>;

	val Bool = Int<bool=> bool == 0 || bool == 1>;
	val true: Bool = 1;
	val false: Bool = 0;

	val Square: Int->Int = n=>n*n;

	val Abs: Int->PositiveInt = n=> n match {
		n: NegativeInt => -n;
		n: PositiveInt =>  n;
	};

	val Pow: {Int; Int}->Int = args=> args match {
		{n; exponent: Int<e=>e==0>} => 1;
		{n; exponent: PositiveInt } => n * (Pow{n; exponent-1});
	};

	val Max = let val Max': {Int; Int}->Int = {a;b} => if (a<b) b else a in list=>reduce{Max';list};

	val Min = let val Min': {Int; Int}->Int = {a;b} => if (a<b) a else b in list=>reduce{Min';list};

	val Pi: Int = 3;

	val range = let val range' = {current:Int; end:Int; rangeList} => 
			if (current == end) 
				rangeList 
			else 
				range'({current + 1; end; rangeList + (current+1)})
		in p:{Int;Int} => range'(p+{p[0]});

	var head = list=>list[0];

	var tail = l=>{
		var all = {}; 
		var first = true; 
		for (elem:l) 
			if (first) 
				first = false 
			else 
				all = all + elem;
		all}[-1];

	val map = {f; iter} => for(i:iter) f(i);

	val filter: {Any->Any; Any} -> Any = let val filter' = {f; iter; current} => 
			if (length(iter) == 0) 
				current 
			else if (f(head(iter))) 
				filter'{f; tail iter; current + (head(iter))} 
			else 
				filter'{f; tail iter; current}
		in args=>filter'(args + {});

	val listConcat = {list1;list2}=>{
		var total = list1;
		for(elem:list2) 
			total = total + elem; 
		total
	}[-1];

	val listConcat' = {l1; l2}=>l2 match {
		{elem} 	=> l1 + elem;
		els 	=> listConcat'({l1 + (head(l2)); tail(l2)})
	};

	val reduce = {f; iter}=>iter match {
		{head}		=>head;
		otherwise	=>reduce{f; 
							listConcat{
								{f{otherwise[0]; otherwise[1]}}; 
								tail(tail(otherwise))
							}
						};
					};
};