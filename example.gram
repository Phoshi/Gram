module {
	val PositiveInt = Int<(x=>x>-1)>;
	val NegativeInt = Int<(x=>x< 1)>;

	val Bool = Int<bool=> bool == 0 || bool == 1>;
	val true: Bool = 1;
	val false: Bool = 0;

	val Square: Int->Int = n=>n*n;

	val Abs: Int->PositiveInt = n=> n match {
		n: NegativeInt => -n;
		n: PositiveInt =>  n;
	};

	val Eq = item => Any<any=>any==item>;

	val Pow: {Int; Int}->Int = args=> args match {
		{n; exponent: Eq 0} => 1;
		{n; exponent: PositiveInt } => n * (Pow{n; exponent-1});
	};

	val Max = let val Max': {Int; Int}->Int = {a;b} => if (a<b) b else a in list=>reduce{Max';list};

	val Min = let val Min': {Int; Int}->Int = {a;b} => if (a<b) a else b in list=>reduce{Min';list};

	val Pi: Int = 3;

	val range = let val range' = {current:Int; end:Int; rangeList} => 
			if (current == end) 
				rangeList 
			else 
				range'({current + 1; end; rangeList + (current+1)})
		in p:{Int;Int} => range'(p+{p[0]});

	var head = {head;_...}=>head;

	var tail = {_;tail...}=>tail;

	val map = {f; iter} => for(i:iter) f(i);

	val filter: {Any->Any; Any} -> Any = let val filter' = {f; iter; current} => 
			if (length(iter) == 0) 
				current 
			else if (f(head(iter))) 
				filter'{f; tail iter; current + (head(iter))} 
			else 
				filter'{f; tail iter; current}
		in args=>filter'(args + {});

	val listConcat = let val concat' = {l1; l2}=>l2 match {
				{} 	=> l1;
				els => concat'{l1 + (head(l2)); tail(l2)}
			}
		in args=>reduce{concat'; args};

	val reduce = {f; iter}=>iter match {
		{head}		=>head;
		{one; two}	=>f{one;two};
		otherwise	=>reduce{f; 
							listConcat{
								{f{otherwise[0]; otherwise[1]}}; 
								tail(tail(otherwise))
							}
						};
					};
};