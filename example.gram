module {
	val Math = module {
		val PositiveInt = Int<(x=>x>-1)>;
		val NegativeInt = Int<(x=>x< 1)>;

		val Square: Int->Int = n=>n*n;

		val Abs: Int->PositiveInt = n=> n match {
			n: NegativeInt => -n;
			n: PositiveInt =>  n;
		};

		val Pow: {Int; Int}->Int = args=> args match {
			{n; exponent: Eq 0} => 1;
			{n; exponent: PositiveInt } => n * (Pow{n; exponent-1});
		};

		val Max = list=>reduce{Max';list} where val Max': {Int; Int}->Int = {a;b} => if (a<b) b else a;

		val Min = list=>reduce{Min';list} where val Min': {Int; Int}->Int = {a;b} => if (a<b) a else b;

		val Pi: Int = 3;
	};

	val Rng = args => args match {
			{}			=> mkRng 5; #{5 is the randomly chosen integer providing this RNG's entropy}#
			seed: Int	=> mkRng seed;
		}
		where val mkRng = s => module {
									var seed = s;
									val a = 1103515245;
									val c = 12345;
									val m = Math::Pow{2;30};

									val Next: {}->Int = {}=>let seed = Math::Abs((seed * a + c) % m) in seed;
								};

	val Bool = Int<bool=> bool == 0 || bool == 1>;
	val true: Bool = 1;
	val false: Bool = 0;

	val Eq = item => typeof(item)<any=>any==item>;

	val range = p:{Int;Int} => range'(p+{p[0]})
		where val range' = {current:Int; end:Int; rangeList} => 
			if (current == end) 
				rangeList 
			else 
				range'({current + 1; end; rangeList + (current+1)});

	var head = {head;_...}=>head;

	var tail = {_;tail...}=>tail;

	val map = {f; iter} => for(i:iter) f(i);

	val filter: {Any->Any; Any} -> Any = args=>filter'(args + {})
		where val filter' = {f; iter; current} => 
			if (length(iter) == 0) 
				current 
			else if (f(head(iter))) 
				filter'{f; tail iter; current + (head(iter))} 
			else 
				filter'{f; tail iter; current};

	val listConcat = args=>reduce{concat'; args} 
		where val concat' = {l1; l2}=>l2 match {
				{} 	=> l1;
				els => concat'{l1 + (head(l2)); tail(l2)}
			};

	val reduce = {f; iter}=>iter match {
		{head}		=>head;
		{one; two}	=>f{one;two};
		otherwise	=>reduce{f; 
							listConcat{
								{f{otherwise[0]; otherwise[1]}}; 
								tail(tail(otherwise))
							}
						};
					};

	var repeat = {f;n}=>n match{
		n: Eq 0 => {};
		n: Eq 1 => {f{}};	
		n       => listConcat{{f{}}; repeat{f;n-1}};
	};
};